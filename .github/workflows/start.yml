name: Start Command

on:
  issue_comment:
    types: [created]

jobs:
  # /start development - 开始开发新功能
  start-development:
    if: |
      github.event.issue.pull_request == null &&
      (startsWith(github.event.comment.body, '/start development') || 
       startsWith(github.event.comment.body, '/start dev'))
    runs-on: ubuntu-latest
    
    permissions:
      issues: write
      contents: write
      
    steps:
      - name: Checkout repository
        uses: actions/checkout@v4
        with:
          token: ${{ secrets.PAT_TOKEN || secrets.GITHUB_TOKEN }}
          fetch-depth: 0
          
      - name: Parse command
        id: parse
        uses: actions/github-script@v7
        with:
          script: |
            const comment = context.payload.comment.body;
            // Support: /start development [#issue] [--from-branch branch]
            const match = comment.match(/\/start (?:development|dev)(?:\s+#?(\d+))?(?:\s+--from-branch\s+(\S+))?/);
            
            if (!match) {
              core.setFailed('Invalid command format');
              return;
            }
            
            // If no issue number provided, use current issue
            const issueNumber = match[1] || context.issue.number;
            const fromBranch = match[2] || '';
            
            core.setOutput('issue_number', issueNumber);
            core.setOutput('from_branch', fromBranch);
            
            console.log(`📋 Issue: #${issueNumber}`);
            console.log(`📌 Base branch: ${fromBranch || 'auto-detect'}`);
            
      - name: Get issue details
        id: issue
        uses: actions/github-script@v7
        with:
          script: |
            const issueNumber = ${{ steps.parse.outputs.issue_number }};
            const fromBranchParam = '${{ steps.parse.outputs.from_branch }}';
            
            // Get issue details
            const { data: issue } = await github.rest.issues.get({
              owner: context.repo.owner,
              repo: context.repo.repo,
              issue_number: parseInt(issueNumber)
            });
            
            // Auto-detect base branch if not specified (prefer develop)
            let fromBranch = fromBranchParam;
            if (!fromBranch) {
              const { data: branches } = await github.rest.repos.listBranches({
                owner: context.repo.owner,
                repo: context.repo.repo,
                per_page: 100
              });
              
              const branchNames = branches.map(b => b.name);
              
              // Priority: develop > dev > main > master
              if (branchNames.includes('develop')) {
                fromBranch = 'develop';
              } else if (branchNames.includes('dev')) {
                fromBranch = 'dev';
              } else if (branchNames.includes('main')) {
                fromBranch = 'main';
              } else if (branchNames.includes('master')) {
                fromBranch = 'master';
              } else {
                const { data: repo } = await github.rest.repos.get({
                  owner: context.repo.owner,
                  repo: context.repo.repo
                });
                fromBranch = repo.default_branch;
              }
              
              console.log(`🔍 Auto-detected base branch: ${fromBranch}`);
            }
            
            core.setOutput('from_branch', fromBranch);
            
            // Extract type from labels
            const typeLabel = issue.labels.find(l => l.name.startsWith('type:'));
            const type = typeLabel ? typeLabel.name.split(':')[1].trim() : 'feature';
            
            // Create branch name
            const sanitizedTitle = issue.title
              .toLowerCase()
              .replace(/[^a-z0-9]+/g, '-')
              .replace(/^-|-$/g, '')
              .substring(0, 50);
            
            const branchName = `${type}/#${issueNumber}-${sanitizedTitle}`;
            
            core.setOutput('title', issue.title);
            core.setOutput('number', issueNumber);
            core.setOutput('type', type);
            core.setOutput('branch_name', branchName);
            core.setOutput('assignee', issue.assignee?.login || '');
            
      - name: Create and push branch
        id: branch
        run: |
          BRANCH_NAME="${{ steps.issue.outputs.branch_name }}"
          FROM_BRANCH="${{ steps.issue.outputs.from_branch }}"
          
          # Fetch all branches
          git fetch origin
          
          # Check if branch already exists
          if git ls-remote --heads origin "$BRANCH_NAME" | grep -q .; then
            echo "❌ Branch $BRANCH_NAME already exists"
            echo "exists=true" >> $GITHUB_OUTPUT
            exit 0
          fi
          
          # Create new branch from base branch
          git checkout -B "$BRANCH_NAME" "origin/$FROM_BRANCH"
          
          # Push the new branch
          git push -u origin "$BRANCH_NAME"
          
          echo "exists=false" >> $GITHUB_OUTPUT
          echo "✅ Created and pushed branch: $BRANCH_NAME"
          
      - name: Update issue and comment
        uses: actions/github-script@v7
        with:
          script: |
            const issueNumber = ${{ steps.issue.outputs.number }};
            const branchName = '${{ steps.issue.outputs.branch_name }}';
            const fromBranch = '${{ steps.issue.outputs.from_branch }}';
            const branchExists = '${{ steps.branch.outputs.exists }}' === 'true';
            const assignee = '${{ steps.issue.outputs.assignee }}';
            const currentUser = context.payload.comment.user.login;
            
            // Update issue state and assignee
            if (!branchExists) {
              const updates = {
                owner: context.repo.owner,
                repo: context.repo.repo,
                issue_number: parseInt(issueNumber),
                labels: ['in-progress']
              };
              
              // Assign to command user if no assignee
              if (!assignee) {
                updates.assignees = [currentUser];
              }
              
              await github.rest.issues.update(updates);
            }
            
            // Post comment with instructions
            const message = branchExists 
              ? `⚠️ **Branch already exists**\n\nThe branch \`${branchName}\` already exists. You can continue working on it.`
              : `🚀 **Development Started!**
              
              **Branch**: \`${branchName}\`
              **Base**: \`${fromBranch}\`
              **Assigned to**: @${assignee || currentUser}
              
              ### Next Steps:
              \`\`\`bash
              # Pull the latest changes
              git fetch origin
              git checkout ${branchName}
              
              # Start developing...
              # When ready, create a PR to ${fromBranch}
              \`\`\`
              
              ### Workflow:
              1. Develop your feature
              2. Commit changes with conventional commits (feat:, fix:, etc.)
              3. Create PR to \`${fromBranch}\`
              4. Changeset will be auto-generated on PR
              5. After review and merge, changesets accumulate in \`${fromBranch}\`
              `;
            
            await github.rest.issues.createComment({
              owner: context.repo.owner,
              repo: context.repo.repo,
              issue_number: context.issue.number,
              body: message
            });

  # /start release - 开始发布流程
  start-release:
    if: |
      github.event.issue.pull_request == null &&
      startsWith(github.event.comment.body, '/start release')
    runs-on: ubuntu-latest
    
    permissions:
      contents: write
      issues: write
      pull-requests: write
      
    steps:
      - name: Parse command
        id: parse
        uses: actions/github-script@v7
        with:
          script: |
            const command = context.payload.comment.body.trim();
            // Parse: /start release [version] [--preview]
            const match = command.match(/^\/start release(?:\s+([\d.]+(?:-\w+)?))?(?:\s+(--preview))?$/);
            
            if (!match) {
              core.setFailed('Invalid command format');
              return;
            }
            
            const version = match[1];
            const isPreview = match[2] === '--preview';
            core.setOutput('version', version || '');
            core.setOutput('preview', isPreview);
            console.log(`📦 Version: ${version || 'auto-detect'}`);
            console.log(`👁️ Preview mode: ${isPreview}`);
            
      - name: Checkout develop
        uses: actions/checkout@v4
        with:
          ref: develop
          fetch-depth: 0
          token: ${{ secrets.PAT_TOKEN || secrets.GITHUB_TOKEN }}
          
      - name: Setup Node.js
        uses: actions/setup-node@v4
        with:
          node-version: '20'
          
      - name: Install dependencies
        run: |
          if [ -f "pnpm-lock.yaml" ]; then
            npm install -g pnpm
            pnpm install
          elif [ -f "yarn.lock" ]; then
            npm install -g yarn
            yarn install
          else
            npm install
          fi
          
      - name: Check changesets
        id: check
        run: |
          # Count available changesets
          CHANGESET_COUNT=$(ls -1 .changeset/*.md 2>/dev/null | grep -v README.md | wc -l)
          echo "changeset_count=$CHANGESET_COUNT" >> $GITHUB_OUTPUT
          
          if [ "$CHANGESET_COUNT" -eq 0 ]; then
            echo "❌ No changesets found in develop branch"
            echo "has_changesets=false" >> $GITHUB_OUTPUT
            exit 0
          fi
          
          echo "has_changesets=true" >> $GITHUB_OUTPUT
          echo "📦 Found $CHANGESET_COUNT changesets to consume"
          
          # List changesets for reference
          echo "Changesets to be consumed:"
          ls -1 .changeset/*.md | grep -v README.md
          
      - name: Determine version
        if: steps.check.outputs.has_changesets == 'true'
        id: version
        run: |
          if [ -n "${{ steps.parse.outputs.version }}" ]; then
            VERSION="${{ steps.parse.outputs.version }}"
          else
            # Get current version from package.json
            CURRENT_VERSION=$(node -p "require('./package.json').version")
            
            # Run changeset version in dry-run mode to see what version it would create
            npx changeset status --output=changeset-status.json || true
            
            if [ -f "changeset-status.json" ]; then
              # Parse the suggested version
              VERSION=$(node -p "
                const status = require('./changeset-status.json');
                const releases = status.releases || [];
                const pkg = releases[0];
                pkg ? pkg.newVersion : '${CURRENT_VERSION}'
              " 2>/dev/null || echo "$CURRENT_VERSION")
            else
              VERSION="$CURRENT_VERSION"
            fi
          fi
          
          # Ensure it's a prerelease version for release branch
          if ! echo "$VERSION" | grep -qE '-(alpha|beta|rc|next)'; then
            VERSION="${VERSION}-beta.0"
          fi
          
          echo "version=$VERSION" >> $GITHUB_OUTPUT
          echo "📌 Release version: $VERSION"
          
      - name: Create release branch
        if: steps.check.outputs.has_changesets == 'true' && steps.parse.outputs.preview != 'true'
        id: branch
        run: |
          VERSION="${{ steps.version.outputs.version }}"
          # Remove prerelease suffix for branch name (1.2.0-beta.0 -> 1.2.0)
          BASE_VERSION=$(echo "$VERSION" | sed 's/-.*$//')
          BRANCH_NAME="release/${BASE_VERSION}"
          
          # Check if branch already exists
          if git ls-remote --heads origin "$BRANCH_NAME" | grep -q .; then
            echo "❌ Release branch $BRANCH_NAME already exists"
            echo "exists=true" >> $GITHUB_OUTPUT
            exit 1
          fi
          
          # Create and checkout release branch
          git checkout -b "$BRANCH_NAME"
          
          echo "branch=$BRANCH_NAME" >> $GITHUB_OUTPUT
          echo "exists=false" >> $GITHUB_OUTPUT
          echo "✅ Created branch: $BRANCH_NAME"
          
      - name: Preview changesets (dry run)
        if: steps.check.outputs.has_changesets == 'true' && steps.parse.outputs.preview == 'true'
        id: preview
        run: |
          echo "🔍 Analyzing changesets (preview mode)..."
          
          # Count changesets by type
          MAJOR_COUNT=0
          MINOR_COUNT=0
          PATCH_COUNT=0
          
          for file in .changeset/*.md; do
            [ -f "$file" ] || continue
            [ "$file" = ".changeset/README.md" ] && continue
            
            # Parse the changeset file to determine version type
            if grep -q "major" "$file"; then
              MAJOR_COUNT=$((MAJOR_COUNT + 1))
            elif grep -q "minor" "$file"; then
              MINOR_COUNT=$((MINOR_COUNT + 1))
            elif grep -q "patch" "$file"; then
              PATCH_COUNT=$((PATCH_COUNT + 1))
            fi
          done
          
          # Determine next version type
          if [ $MAJOR_COUNT -gt 0 ]; then
            VERSION_TYPE="major"
          elif [ $MINOR_COUNT -gt 0 ]; then
            VERSION_TYPE="minor"
          else
            VERSION_TYPE="patch"
          fi
          
          echo "major_count=$MAJOR_COUNT" >> $GITHUB_OUTPUT
          echo "minor_count=$MINOR_COUNT" >> $GITHUB_OUTPUT
          echo "patch_count=$PATCH_COUNT" >> $GITHUB_OUTPUT
          echo "version_type=$VERSION_TYPE" >> $GITHUB_OUTPUT
          
      - name: Consume changesets
        if: steps.check.outputs.has_changesets == 'true' && steps.branch.outputs.exists != 'true' && steps.parse.outputs.preview != 'true'
        id: consume
        run: |
          echo "🔄 Consuming changesets..."
          
          # Configure git
          git config user.name "github-actions[bot]"
          git config user.email "github-actions[bot]@users.noreply.github.com"
          
          # Run changeset version to consume changesets
          npx changeset version
          
          # Get the new version
          NEW_VERSION=$(node -p "require('./package.json').version")
          echo "new_version=$NEW_VERSION" >> $GITHUB_OUTPUT
          
          # Commit version bump
          git add .
          git commit -m "chore: release version $NEW_VERSION

          Consumed ${{ steps.check.outputs.changeset_count }} changesets from develop branch" || echo "No changes to commit"
          
      - name: Push release branch
        if: steps.check.outputs.has_changesets == 'true' && steps.branch.outputs.exists != 'true'
        run: |
          git push -u origin "${{ steps.branch.outputs.branch }}"
          
      - name: Clean develop branch
        if: steps.check.outputs.has_changesets == 'true' && steps.branch.outputs.exists != 'true'
        run: |
          # Switch back to develop
          git checkout develop
          
          # Remove consumed changesets
          rm -f .changeset/*.md
          echo "# Changesets consumed by ${{ steps.branch.outputs.branch }}" > .changeset/.consumed
          
          # Commit the cleanup
          git add .changeset/
          git commit -m "chore: clear changesets consumed by ${{ steps.branch.outputs.branch }}" || echo "No changesets to clear"
          git push origin develop
          
      - name: Create PR
        if: steps.check.outputs.has_changesets == 'true' && steps.branch.outputs.exists != 'true'
        id: pr
        env:
          GH_TOKEN: ${{ secrets.GITHUB_TOKEN }}
        run: |
          BRANCH="${{ steps.branch.outputs.branch }}"
          VERSION="${{ steps.consume.outputs.new_version }}"
          
          # Create PR from release to main
          PR_URL=$(gh pr create \
            --base main \
            --head "$BRANCH" \
            --title "🚀 Release $VERSION" \
            --body "## Release $VERSION
            
            ### Changesets Consumed
            - **Count**: ${{ steps.check.outputs.changeset_count }} changesets
            - **Source**: develop branch
            - **Version**: $VERSION
            
            ### Release Checklist
            - [ ] Run tests: \`/test\`
            - [ ] Create beta release: \`/release beta\`
            - [ ] Publish beta: \`/publish npm --tag next\`
            - [ ] Test beta version
            - [ ] Create RC if needed: \`/release rc\`
            - [ ] Final review
            - [ ] Approve and merge PR
            - [ ] Create final release: \`/release\`
            - [ ] Publish to npm: \`/publish\`
            
            ### Notes
            This release branch was created from develop with accumulated changesets.
            All changesets have been consumed and cleared from develop.
            ")
            
          echo "pr_url=$PR_URL" >> $GITHUB_OUTPUT
          
      - name: Comment result
        uses: actions/github-script@v7
        with:
          script: |
            const hasChangesets = '${{ steps.check.outputs.has_changesets }}' === 'true';
            const branchExists = '${{ steps.branch.outputs.exists }}' === 'true';
            const isPreview = '${{ steps.parse.outputs.preview }}' === 'true';
            
            if (!hasChangesets) {
              await github.rest.issues.createComment({
                owner: context.repo.owner,
                repo: context.repo.repo,
                issue_number: context.issue.number,
                body: `❌ **No changesets to release**
                
                There are no changesets in the develop branch to consume.
                Please ensure features have been merged with changesets before starting a release.`
              });
              return;
            }
            
            // Preview mode response
            if (isPreview) {
              const version = '${{ steps.version.outputs.version }}';
              const changesetCount = '${{ steps.check.outputs.changeset_count }}';
              const majorCount = '${{ steps.preview.outputs.major_count }}' || '0';
              const minorCount = '${{ steps.preview.outputs.minor_count }}' || '0';
              const patchCount = '${{ steps.preview.outputs.patch_count }}' || '0';
              const versionType = '${{ steps.preview.outputs.version_type }}';
              
              let emoji = '🩹';
              if (versionType === 'major') emoji = '💥';
              else if (versionType === 'minor') emoji = '✨';
              
              await github.rest.issues.createComment({
                owner: context.repo.owner,
                repo: context.repo.repo,
                issue_number: context.issue.number,
                body: `### 👁️ Release Preview
                
                **Next version**: \`${version}\` (${emoji} ${versionType})
                **Total changesets**: ${changesetCount}
                
                ### Breakdown:
                - 💥 Major: ${majorCount}
                - ✨ Minor: ${minorCount}
                - 🩹 Patch: ${patchCount}
                
                ### Ready to release?
                Run \`/start release\` to:
                1. Create release branch \`release/${version.split('-')[0]}\`
                2. Consume all changesets
                3. Create PR to main
                4. Begin release process
                
                ### Not ready yet?
                Continue developing on \`develop\` branch.
                New changesets will be included in the next release.`
              });
              return;
            }
            
            if (branchExists) {
              await github.rest.issues.createComment({
                owner: context.repo.owner,
                repo: context.repo.repo,
                issue_number: context.issue.number,
                body: `❌ **Release branch already exists**
                
                The release branch already exists. Please complete the current release before starting a new one.`
              });
              return;
            }
            
            const branch = '${{ steps.branch.outputs.branch }}';
            const version = '${{ steps.consume.outputs.new_version }}';
            const prUrl = '${{ steps.pr.outputs.pr_url }}';
            const changesetCount = '${{ steps.check.outputs.changeset_count }}';
            
            await github.rest.issues.createComment({
              owner: context.repo.owner,
              repo: context.repo.repo,
              issue_number: context.issue.number,
              body: `### 🎉 Release Started!
              
              **Branch**: \`${branch}\`
              **Version**: \`${version}\`
              **Changesets**: ${changesetCount} consumed from develop
              **PR**: ${prUrl}
              
              ### Next Steps:
              1. Switch to release branch: \`git checkout ${branch}\`
              2. Run tests: \`/test\`
              3. Create beta release: \`/release beta\`
              4. Publish beta: \`/publish npm --tag next\`
              5. Test the beta version
              6. When ready, merge PR to main
              7. After merge, run \`/release\` on main
              8. Finally, \`/publish\` to npm
              
              ### Important:
              - Changesets have been consumed and cleared from develop
              - New features can continue to be developed on develop
              - This release branch is independent and won't affect ongoing development
              `
            });